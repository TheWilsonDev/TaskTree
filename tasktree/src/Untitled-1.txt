//////////////// FILE HEADER (INCLUDE IN EVERY FILE) //////////////////////////
//
// Title:    Election Manager: Candidate Polling and Ranking System
// Course:   CS 300 Fall 2024
//
// Author:   Adrian Wilson
// Email:    arwilson25@wisc.edu
// Lecturer: Hobbes LeGault
//
//////////////////////// ASSISTANCE/HELP CITATIONS ////////////////////////////
//
// Online Sources:
//  - ChatGPT (Screenshots on gradescope)
//  - Github Copilot (filled in what I was already typing, didn't use the chat)
//  - https://stackoverflow.com/questions/14721397/checking-if-a-string-is-empty-or-null-in-java
//  - https://stackoverflow.com/questions/9493563/comparing-2d-arrays
//  - https://stackoverflow.com/questions/7970857/java-shifting-elements-in-an-array
//  - https://stackoverflow.com/questions/1564832/how-do-i-do-a-deep-copy-of-a-2d-array-in-java
//  - https://www.w3schools.com/java/ref_string_equals.asp
//  - https://stackoverflow.com/questions/7899525/how-to-split-a-string-by-space
//  - https://stackoverflow.com/questions/14945656/list-an-array-of-strings-in-alphabetical-order
//  - https://howtodoinjava.com/java-examples/sort-string-array-alphabetically/
///////////////////////////////////////////////////////////////////////////////

import java.util.Arrays;

/**
 * ElectionManagerTester is designed to test
 * the ElectionManager class by testing
 * different functionalities of methods
 * that perform actions that may take
 * place during an election process.
 */
public class ElectionManagerTester {
  /**
   * Tests containsCandidate when the
   * candidate list is empty with only
   * null values.
   * 
   * @return  false if any of the scenarios we test have results other than what we expect;
   * true ONLY if all of our expectations are met by the method we are testing
   */
  public static boolean testContainsEmpty() {
    String[][] candidateList = { null, null, null, null, null, null };
    String[][] candidateCopy = Arrays.copyOf(
      candidateList,
      candidateList.length
    );
    int size = 0;
    String targetName = "Nonexisting";
    String targetParty = "Name";
    boolean expected = false;

    // (1b) call the method we are testing
    boolean actual = ElectionManager.containsCandidate(
      candidateList,
      size,
      targetName,
      targetParty
    );

    // (2) verify that the expected method return value and the actual return value match
    if (expected != actual) return false;

    // (3) since THIS method should not modify the array, check it against a copy we made
    if (!Arrays.deepEquals(candidateList, candidateCopy)) return false;

    // (4) if we have not yet returned false, we can now return true as all tests have passed!
    return true;
  }

  /**
   * Tests containsCandidate when
   * the target candidate is not 
   * present in the candidate list
   * 
   * @return  false if any of the scenarios we test have results other than what we expect;
   * true ONLY if all of our expectations are met by the method we are testing
   */
  public static boolean testDoesNotContain() {
    // 1(a) set up the test variables
    String[][] candidateList = {
      { "Slowpoke", "Water", "3" },
      { "Squirtle", "Water", "127" },
      { "Wooper", "Water", "300" },
      null,
      null,
      null,
    };
    String[][] candidateCopy = Arrays.copyOf(
      candidateList,
      candidateList.length
    );
    int size = 3;
    String targetName = "Nonexisting";
    String targetParty = "Name";
    boolean expected = false;

    // (1b) call the method we are testing
    boolean actual = ElectionManager.containsCandidate(
      candidateList,
      size,
      targetName,
      targetParty
    );

    // (2) verify that the expected method return value and the actual return value match
    if (expected != actual) return false;

    // (3) since THIS method should not modify the array, check it against a copy we made
    if (!Arrays.deepEquals(candidateList, candidateCopy)) return false;

    // (4) if we have not yet returned false, we can now return true as all tests have passed!
    return true;
  }

  /**
   * PROVIDED TESTER METHOD: example test method for verifying whether a candidate has
   * already been added to the race.
   *
   * NOTE: This method ONLY tests scenarios where the candidate IS PRESENT in the list;
   * situations where the candidate is not present or the list is empty should be
   * tested in the other contains tester methods.
   *
   * @return false if any of the scenarios we test have results other than what we expect;
   * true ONLY if all of our expectations are met by the method we are testing
   */
  public static boolean testDoesContain() {
    // (1a) set up the test variables
    String[][] candidateList = {
      { "Slowpoke", "Water", "3" },
      { "Squirtle", "Water", "127" },
      { "Wooper", "Water", "300" },
      null,
      null,
      null,
    };
    String[][] candidateCopy = Arrays.copyOf(
      candidateList,
      candidateList.length
    );
    int size = 3;
    String targetName = "Wooper";
    String targetParty = "Water";
    boolean expected = true;

    // (1b) call the method we are testing
    boolean actual = ElectionManager.containsCandidate(
      candidateList,
      size,
      targetName,
      targetParty
    );

    // (2) verify that the expected method return value and the actual return value match
    if (expected != actual) return false;

    // (3) since THIS method should not modify the array, check it against a copy we made
    if (!Arrays.deepEquals(candidateList, candidateCopy)) return false;

    // (4) if we have not yet returned false, we can now return true as all tests have passed!
    return true;
  }

  /**
   * Tests addCandidate when adding a candidate
   * to a candidate list that is completely
   * empty/contains only null values
   * 
   * @return  false if any of the scenarios we test have results other than what we expect;
   * true ONLY if all of our expectations are met by the method we are testing
   */
  public static boolean testAddToEmpty() {
    // (1a) set up the test variables
    String[][] candidateList = {
      null,
      null,
      null,
      null,
      null,
      null,
    };
    String newName = "Blah";
    String newParty = "Blah123323";
    int newVotes = 2093;

    String[][] expectedList = {
      { "Blah", "Blah123323", "2093" },
      null,
      null,
      null,
      null,
      null,
    }; 
    int size = 0;
    int expected = 1;

    // (1b) call the method we are testing
    int actual = ElectionManager.addCandidate(
      candidateList,
      size,
      newName,
      newParty,
      newVotes
    );

    // (2) verify that the expected method return value and the actual return value match
    if (expected != actual) return false;

    // (3) this method modifies the input array; verify that it was modified correctly
    if (!Arrays.deepEquals(candidateList, expectedList)) return false;

    // (4) if we have not yet returned false, we can now return true as all tests have passed!
    return true;
  }

  /**
   * PROVIDED TESTER METHOD: example test method for verifying whether a new candidate has
   * been added correctly to the race.
   *
   * @return false if any of the scenarios we test have results other than what we expect;
   * true ONLY if all of our expectations are met by the method we are testing
   */
  public static boolean testAddToNonEmpty() {
    // (1a) set up the test variables
    String[][] candidateList = {
      { "Slowpoke", "Water", "3" },
      { "Squirtle", "Water", "127" },
      { "Wooper", "Water", "300" },
      null,
      null,
      null,
    };
    String newName = "Goldeen";
    String newParty = "Water";
    int newVotes = 5;

    String[][] expectedList = {
      { "Goldeen", "Water", "5" },
      { "Slowpoke", "Water", "3" },
      { "Squirtle", "Water", "127" },
      { "Wooper", "Water", "300" },
      null,
      null,
    }; // now only TWO null values in this length-6 array!
    int size = 3;
    int expected = 4;

    // (1b) call the method we are testing
    int actual = ElectionManager.addCandidate(
      candidateList,
      size,
      newName,
      newParty,
      newVotes
    );

    // (2) verify that the expected method return value and the actual return value match
    if (expected != actual) return false;

    // (3) this method modifies the input array; verify that it was modified correctly
    if (!Arrays.deepEquals(candidateList, expectedList)) return false;

    // (4) if we have not yet returned false, we can now return true as all tests have passed!
    return true;
  }

  /**
   * Tests addCandidate when the
   * candidate is already present
   * in the candidate list
   * 
   * @return  false if any of the scenarios we test have results other than what we expect;
   * true ONLY if all of our expectations are met by the method we are testing
   */
  public static boolean testAddCandidateErrors() {
    // (1a) set up the test variables
    String[][] candidateList = {
      { "Slowpoke", "Water", "3" },
      { "Squirtle", "Water", "127" },
      { "Wooper", "Water", "300" },
      null, null, null
    };
    String[][] candidateCopy = Arrays.copyOf(candidateList, candidateList.length);
    int size = 3;

    // (1b) duplicate candidate
    String dupCandidateName = "Slowpoke";
    String dupCandidateParty = "Water";
    int dupCandidateVotes = 3;
    int expected = size;

    // (1c) call the method we are testing
    int actual = ElectionManager.addCandidate(candidateList, size, dupCandidateName, dupCandidateParty, dupCandidateVotes);

    // (2a) negative vote count test
    String negVotesName = "bbooopepoeif";
    String negVotesParty = "OFIJWijafiaw";
    int negVotes = -12403;
    expected = size;

    // (2b) call the method we are testing
    actual = ElectionManager.addCandidate(candidateList, size, negVotesName, negVotesParty, negVotes);

    // (3) verify that the expected method return value and the actual return value match
    if (expected != actual) return false;

    // (4) this method modifies the input array; verify that it was modified correctly
    if (!Arrays.deepEquals(candidateList, candidateCopy)) return false;

    // (4) if we have not yet returned false, we can now return true as all tests have passed!
    return true;
  }

  /**
   * Tests addCandidate when the
   * candidate list is already full
   * 
   * @return  false if any of the scenarios we test have results other than what we expect;
   * true ONLY if all of our expectations are met by the method we are testing
   */
  public static boolean testAddToFull() {
    // (1a) set up the test variables
    String[][] candidateList = {
        { "Slowpoke", "Water", "3" },
        { "Squirtle", "Water", "127" },
        { "Wooper", "Water", "300" }
    }; 
    String[][] candidateCopy = Arrays.copyOf(candidateList, candidateList.length);
    int size = 3;
    
    // (1b) the new candidate thats going to be added
    String newName = "asdflaskfj";
    String newParty = "wooowooowoo";
    int newVotes = 150;
    int expected = size; 

    // (1c) call the method we are testing
    int actual = ElectionManager.addCandidate(candidateList, size, newName, newParty, newVotes);

    // (2) verify that the expected method return value and the actual return value match
    if (expected != actual) return false;

    // (4) this method modifies the input array; verify that it was modified correctly
    if (!Arrays.deepEquals(candidateList, candidateCopy)) return false;

    // (4) If all tests pass, return true
    return true;
}

  /**
   * Tests dropCandidate when its the
   * only candidate in the list
   * 
   * @return  false if any of the scenarios we test have results other than what we expect;
   * true ONLY if all of our expectations are met by the method we are testing
   */
  public static boolean testDropOnlyCandidate() {
    // (1a) set up the test variables
    String[][] candidateList = {
      { "DROP", "ME", "1" },
      null,
      null,
      null,
      null,
      null,
    };
    String[][] expectedList = {
      null,
      null, 
      null,
      null, 
      null,
      null,
    };
    int size = 1;
    int expected = 0;

    // (1b) call the method we are testing
    int actual = ElectionManager.dropCandidate(candidateList, size, "DROP", "ME");

    // (2) verify that the expected method return value and the actual return value match
    if (expected != actual) return false;

    // (3) this scenario should NOT modify the input array; check it against a copy we made
    if (!Arrays.deepEquals(candidateList, expectedList)) return false;

    // (4) if we have not yet returned false, we can now return true as all tests have passed!
    return true;
  }

  /**
   * Tests dropCandidate when its
   * dropping the first candidate 
   * in the list
   * 
   * @return  false if any of the scenarios we test have results other than what we expect;
   * true ONLY if all of our expectations are met by the method we are testing
   */
  public static boolean testDropFirstCandidate() {
    // (1a) set up the test variables
    String[][] candidateList = {
      { "Slowpoke", "Water", "3" },
      { "Squirtle", "Water", "127" },
      { "Wooper", "Water", "300" },
      null,
      null,
      null,
    };
    String[][] expectedList = {
      { "Squirtle", "Water", "127" },
      { "Wooper", "Water", "300" },
      null, null, null, null
    };
    int size = 3;
    int expected = 2;

    // (1b) call the method we are testing
    int actual = ElectionManager.dropCandidate(candidateList, size, "Slowpoke", "Water");

    // (2) verify that the expected method return value and the actual return value match
    if (expected != actual) return false;

    // (3) this scenario should NOT modify the input array; check it against a copy we made
    if (!Arrays.deepEquals(candidateList, expectedList)) return false;

    // (4) if we have not yet returned false, we can now return true as all tests have passed!
    return true;
  }

  /**
   * PROVIDED TESTER METHOD: example test method for verifying whether trying to drop a
   * candidate who is not running in the race correctly has NO effect on the candidate list.
   *
   * @return false if any of the scenarios we test have results other than what we expect;
   * true ONLY if all of our expectations are met by the method we are testing
   */
  public static boolean testDropCandidateNotRunning() {
    // (1a) set up the test variables
    String[][] candidateList = {
      { "Slowpoke", "Water", "3" },
      { "Squirtle", "Water", "127" },
      { "Wooper", "Water", "300" },
      null,
      null,
      null,
    };
    String[][] candidateCopy = Arrays.copyOf(
      candidateList,
      candidateList.length
    );
    String name = "Goldeen";
    String party = "Water";
    int size = 3;
    int expected = 3;

    // (1b) call the method we are testing
    int actual = ElectionManager.dropCandidate(
      candidateList,
      size,
      name,
      party
    );

    // (2) verify that the expected method return value and the actual return value match
    if (expected != actual) return false;

    // (2a) sometimes you may want to REPEAT the process with slightly different variables:
    name = "Slowpoke";
    party = "Fire"; // try with a name that's present but a different PARTY; should still not drop
    actual = ElectionManager.dropCandidate(candidateList, size, name, party);
    if (expected != actual) return false;

    // (3) this scenario should NOT modify the input array; check it against a copy we made
    if (!Arrays.deepEquals(candidateList, candidateCopy)) return false;

    // (4) if we have not yet returned false, we can now return true as all tests have passed!
    return true;
  }

  /**
   * Tests findWinner when
   * there is onl one candidate
   * with 100% of the votes
   * 
   * @return  false if any of the scenarios we test have results other than what we expect;
   * true ONLY if all of our expectations are met by the method we are testing
   */
  public static boolean testUncontestedWinner() {
    // 1(a) set up the test variables
    String[][] candidateList = {
      {"Numba", "One", "100"},
      null,
      null,
      null,
      null,
      null,
    };
    String[][] candidateCopy = Arrays.copyOf(candidateList, candidateList.length);
    String expectedName = "Numba";
    String expectedParty = "(One)";
    double expectedVotePct = 100.0;
    int size = 1;

    // (1b) call the method we are testing
    String result = ElectionManager.findWinner(candidateList, size);

    // (2) verify that the expected method return value and the actual return value match
    // NOTE: for a String, this takes a little more processing to do sensitively.
    // We expect this result to be "Wooper (Water) - 75.0%" but there may be some weirdness
    // especially with that percentage. See how we do it here:

    String[] resultPieces = result.split(" "); // get the space-separated pieces of the string

    if (resultPieces.length != 4) return false; // incorrect formatting
    if (!resultPieces[3].endsWith("%")) return false; // no % at the end

    if (
      !resultPieces[0].equals(expectedName) ||
      !resultPieces[1].equals(expectedParty)
    ) return false; // wrong name or wrong party

    if (!resultPieces[2].equals("-")) return false; // forgot the "-" between party and %

    // do a range check on the calculated vote percentage, since it's not always going to come out
    // exactly the same:
    double actualVotePct = Double.valueOf(
      resultPieces[3].substring(0, resultPieces[3].length() - 1)
    );
    if (Math.abs(actualVotePct - expectedVotePct) > 0.01) return false;

    // (3) this scenario should NOT modify the input array; check it against a copy we made
    if (!Arrays.deepEquals(candidateList, candidateCopy)) return false;

    // (4) if we have not yet returned false, we can now return true as all tests have passed!
    return true;
  }

  /**
   * PROVIDED TESTER METHOD: example test method for verifying the results of an election
   * where one candidate has received a clear majority of the votes cast.
   *
   * @return false if any of the scenarios we test have results other than what we expect;
   * true ONLY if all of our expectations are met by the method we are testing
   */
  public static boolean testClearWinner() {
    // (1a) set up the test variables
    String[][] candidateList = {
      { "Slowpoke", "Water", "3" },
      { "Squirtle", "Water", "97" },
      { "Wooper", "Water", "300" },
      null,
      null,
      null,
    };
    String[][] candidateCopy = Arrays.copyOf(
      candidateList,
      candidateList.length
    );
    String expectedName = "Wooper";
    String expectedParty = "(Water)";
    double expectedVotePct = 300.0 / (300 + 97 + 3) * 100;
    int size = 3;

    // (1b) call the method we are testing
    String result = ElectionManager.findWinner(candidateList, size);

    // (2) verify that the expected method return value and the actual return value match
    // NOTE: for a String, this takes a little more processing to do sensitively.
    // We expect this result to be "Wooper (Water) - 75.0%" but there may be some weirdness
    // especially with that percentage. See how we do it here:

    String[] resultPieces = result.split(" "); // get the space-separated pieces of the string

    if (resultPieces.length != 4) return false; // incorrect formatting
    if (!resultPieces[3].endsWith("%")) return false; // no % at the end

    if (
      !resultPieces[0].equals(expectedName) ||
      !resultPieces[1].equals(expectedParty)
    ) return false; // wrong name or wrong party

    if (!resultPieces[2].equals("-")) return false; // forgot the "-" between party and %

    // do a range check on the calculated vote percentage, since it's not always going to come out
    // exactly the same:
    double actualVotePct = Double.valueOf(
      resultPieces[3].substring(0, resultPieces[3].length() - 1)
    );
    if (Math.abs(actualVotePct - expectedVotePct) > 0.01) return false;

    // (3) this scenario should NOT modify the input array; check it against a copy we made
    if (!Arrays.deepEquals(candidateList, candidateCopy)) return false;

    // (4) if we have not yet returned false, we can now return true as all tests have passed!
    return true;
  }

  /**
   * Tests findWinner when candidates have 
   * the same number of votes
   * 
   * @return  false if any of the scenarios we test have results other than what we expect;
   * true ONLY if all of our expectations are met by the method we are testing
   */
  public static boolean testContingentElection() {
    // (1a) set up the test variables
    String[][] candidateList = {
        { "ee", "ee", "5" },
        { "Squirtle", "Water", "5" },
        null, null, null
    };  
    String[][] candidateCopy = Arrays.copyOf(candidateList, candidateList.length);
    int size = 2;
    String expected = "CONTINGENT";

    // (1b) call the method we are testing
    String result = ElectionManager.findWinner(candidateList, size);

    // (2) verify that the method returned "CONTINGENT"
    if (!result.equals(expected)) return false;

    // (3) this scenario should NOT modify the input array; check it against a copy we made
    if (!Arrays.deepEquals(candidateList, candidateCopy)) return false;

    // (4) if we have not yet returned false, we can now return true as all tests have passed!
    return true;
  }

  /**
   * Tests findLowestPollingCandidate when 
   * its uncontested 
   * 
   * @return  false if any of the scenarios we test have results other than what we expect;
   * true ONLY if all of our expectations are met by the method we are testing
   */
  public static boolean testUncontestedLowestPolling() {
    // (1a) set up the test variables
    String[][] candidateList = {
        { "woowowo", "heloc", "100" },
        null, null, null, null, null
    };  
    String[][] candidateCopy = Arrays.copyOf(candidateList, candidateList.length);
    String expected = "UNCONTESTED";
    int size = 1;

    // (1b) call the method we are testing
    String result = ElectionManager.findLowestPollingCandidate(candidateList, size);

    // (2) verify that the method returned "CONTINGENT"
    if (!result.equals(expected)) return false;

    // (3) this scenario should NOT modify the input array; check it against a copy we made
    if (!Arrays.deepEquals(candidateList, candidateCopy)) return false;

    // (4) if we have not yet returned false, we can now return true as all tests have passed!
    return true;
  }

  /**
  * Tests findLowestPollingCandidate when 
  * other candidates have different vote counts
  * 
  * @return  false if any of the scenarios we test have results other than what we expect;
  * true ONLY if all of our expectations are met by the method we are testing
  */
  public static boolean testLowestUniqueVoteCount() {
    // (1a) set up the test variables
    String[][] candidateList = {
        { "woowowo", "heloc", "6" },
        { "Squirtle", "Water", "1" },
        { "Wooper", "Water", "3" },
        null, null, null
    };  
    String[][] candidateCopy = Arrays.copyOf(candidateList, candidateList.length);
    String expected = "Squirtle (Water) - 1";
    int size = 3;

    // (1b) call the method we are testing
    String result = ElectionManager.findLowestPollingCandidate(candidateList, size);

    // (2) verify that the method returned "CONTINGENT"
    if (!result.equals(expected)) return false;

    // (3) this scenario should NOT modify the input array; check it against a copy we made
    if (!Arrays.deepEquals(candidateList, candidateCopy)) return false;

    // (4) if we have not yet returned false, we can now return true as all tests have passed!
    return true;
  }
  
  /**
  * Tests findLowestPollingCandidate when 
  * other candidates have the same vote counts
  * 
  * @return  false if any of the scenarios we test have results other than what we expect;
  * true ONLY if all of our expectations are met by the method we are testing
  */
  public static boolean testLowestVoteCountTied() {
    // (1a) set up the test variables
    String[][] candidateList = {
        { "woowowo", "heloc", "4" },
        { "Squirtle", "Water", "1" },
        { "Wooper", "Water", "1" },
        null, null, null
    };  
    String[][] candidateCopy = Arrays.copyOf(candidateList, candidateList.length);
    String expected = "Squirtle (Water) - 1"; 
    int size = 3;

    // (1b) call the method we are testing
    String result = ElectionManager.findLowestPollingCandidate(candidateList, size);

    // (2) verify that the method returned "Squirtle (Water) - 1"
    if (!result.equals(expected)) return false;

    // (3) this scenario should NOT modify the input array; check it against a copy we made
    if (!Arrays.deepEquals(candidateList, candidateCopy)) return false;

    // (4) if we have not yet returned false, we can now return true as all tests have passed!
    return true;
  }

  /**
   * PROVIDED MAIN METHOD to manage the tester methods above.
   *
   * We're getting a little esoteric here to take advantage of loops to keep the code short;
   * each pass through the loop could also be written as follows:
   *
   *   boolean singleTest = testMethodCall();
   *   allPass &= singleTest;
   *   System.out.println("testMethodCall : " + singleTest);
   *
   * @throws NoSuchMethodException if you spell a method name incorrectly
   *
   * And a couple of other "checked" exceptions that should never happen with our usage here:
   * @throws IllegalAccessException
   * @throws java.lang.reflect.InvocationTargetException
   */
  public static void main(String[] args)
    throws NoSuchMethodException, IllegalAccessException, java.lang.reflect.InvocationTargetException {
    boolean allPass = true, singlePass = true;
    String printFormat = "%-29s: %s\n";

    // NOTE TO STUDENTS: If you create any additional tests for any of the methods in
    // ElectionManager, add their names to the appropriate array below!
    String[] containsTests = {
      "testContainsEmpty",
      "testDoesNotContain",
      "testDoesContain",
    };
    String[] addTests = {
      "testAddToEmpty",
      "testAddToNonEmpty",
      "testAddCandidateErrors",
      "testAddToFull",
    };
    String[] dropTests = {
      "testDropOnlyCandidate",
      "testDropFirstCandidate",
      "testDropCandidateNotRunning",
    };
    String[] winTests = {
      "testUncontestedWinner",
      "testClearWinner",
      "testContingentElection",
    };
    String[] lowTests = {
      "testUncontestedLowestPolling",
      "testLowestUniqueVoteCount",
      "testLowestVoteCountTied",
    };

    String[][] testNames = {
      containsTests,
      addTests,
      dropTests,
      winTests,
      lowTests,
    };

    // NOTE TO STUDENTS: this for-loop is moving through the method names we've added to the 2D
    // array testNames and attempting to call methods with those names from this tester
    // (specifically line 286 here). See Java's reflection framework for more details!
    for (String[] testSet : testNames) {
      for (String name : testSet) {
        singlePass =
          (boolean) ElectionManagerTester.class.getDeclaredMethod(name)
            .invoke(null);
        allPass &= singlePass;
        System.out.printf(printFormat, name, singlePass);
      }
      System.out.println();
    }

    System.out.println("ALL TESTS: " + allPass);
  }
}
